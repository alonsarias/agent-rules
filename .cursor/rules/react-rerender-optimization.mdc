---
description: React re-render optimization patterns including memo, useMemo, useCallback, useState, useRef, and derived state. Use when components re-render too often, dealing with stale closures, dependency arrays, performance issues, or optimizing slow components.
globs: "*.tsx,*.jsx,*.ts,*.js"
alwaysApply: false
---

# React Re-render Optimization

Patterns for reducing unnecessary re-renders to minimize wasted computation and improve UI responsiveness.

## 1. Calculate Derived State During Rendering

**Impact: MEDIUM** - Avoids redundant renders and state drift

If a value can be computed from current props/state, derive it during render instead of storing in state.

**Incorrect: redundant state and effect**

```tsx
function Form() {
  const [firstName, setFirstName] = useState('First')
  const [lastName, setLastName] = useState('Last')
  const [fullName, setFullName] = useState('')

  useEffect(() => {
    setFullName(firstName + ' ' + lastName)
  }, [firstName, lastName])

  return <span>{fullName}</span>
}
```

**Correct: derive during render**

```tsx
function Form() {
  const [firstName, setFirstName] = useState('First')
  const [lastName, setLastName] = useState('Last')
  const fullName = firstName + ' ' + lastName

  return <span>{fullName}</span>
}
```

Reference: [You Might Not Need an Effect](https://react.dev/learn/you-might-not-need-an-effect)

---

## 2. Defer State Reads to Usage Point

**Impact: MEDIUM** - Avoids unnecessary subscriptions

Don't subscribe to dynamic state if you only read it inside callbacks.

**Incorrect: subscribes to all searchParams changes**

```tsx
function ShareButton({ chatId }: { chatId: string }) {
  const searchParams = useSearchParams()

  const handleShare = () => {
    const ref = searchParams.get('ref')
    shareChat(chatId, { ref })
  }

  return <button onClick={handleShare}>Share</button>
}
```

**Correct: reads on demand, no subscription**

```tsx
function ShareButton({ chatId }: { chatId: string }) {
  const handleShare = () => {
    const params = new URLSearchParams(window.location.search)
    const ref = params.get('ref')
    shareChat(chatId, { ref })
  }

  return <button onClick={handleShare}>Share</button>
}
```

---

## 3. Avoid useMemo for Simple Expressions

**Impact: LOW-MEDIUM** - Wasted computation on every render

When an expression is simple and returns a primitive, don't wrap it in `useMemo`. The hook overhead may exceed the expression cost.

**Incorrect:**

```tsx
function Header({ user, notifications }: Props) {
  const isLoading = useMemo(() => {
    return user.isLoading || notifications.isLoading
  }, [user.isLoading, notifications.isLoading])

  if (isLoading) return <Spinner />
  // ...
}
```

**Correct:**

```tsx
function Header({ user, notifications }: Props) {
  const isLoading = user.isLoading || notifications.isLoading

  if (isLoading) return <Spinner />
  // ...
}
```

---

## 4. Extract Default Non-primitive Props to Constants

**Impact: MEDIUM** - Restores memoization

When a memoized component has a default non-primitive parameter, calling without that prop breaks memoization due to new reference creation.

**Incorrect: `onClick` has different values on every rerender**

```tsx
const UserAvatar = memo(function UserAvatar({ onClick = () => {} }: Props) {
  // ...
})

// Used without optional onClick
<UserAvatar />
```

**Correct: stable default value**

```tsx
const NOOP = () => {}

const UserAvatar = memo(function UserAvatar({ onClick = NOOP }: Props) {
  // ...
})

<UserAvatar />
```

---

## 5. Extract to Memoized Components

**Impact: MEDIUM** - Enables early returns before computation

Extract expensive work into memoized components to skip computation during early returns.

**Incorrect: computes avatar even when loading**

```tsx
function Profile({ user, loading }: Props) {
  const avatar = useMemo(() => {
    const id = computeAvatarId(user)
    return <img src={`/avatar/${id}`} />
  }, [user])

  if (loading) return <Spinner />
  return <div>{avatar}</div>
}
```

**Correct: skips computation when loading**

```tsx
const UserAvatar = memo(function UserAvatar({ user }: { user: User }) {
  const id = useMemo(() => computeAvatarId(user), [user])
  return <img src={`/avatar/${id}`} />
})

function Profile({ user, loading }: Props) {
  if (loading) return <Spinner />
  return (
    <div>
      <UserAvatar user={user} />
    </div>
  )
}
```

**Note:** If using React Compiler, manual memoization is not necessary.

---

## 6. Narrow Effect Dependencies

**Impact: LOW** - Minimizes effect re-runs

Specify primitive dependencies instead of objects.

**Incorrect: re-runs on any user field change**

```tsx
useEffect(() => {
  console.log(user.id)
}, [user])
```

**Correct: re-runs only when id changes**

```tsx
useEffect(() => {
  console.log(user.id)
}, [user.id])
```

**For derived state, compute outside effect:**

```tsx
// Incorrect: runs on width=767, 766, 765...
useEffect(() => {
  if (width < 768) {
    enableMobileMode()
  }
}, [width])

// Correct: runs only on boolean transition
const isMobile = width < 768
useEffect(() => {
  if (isMobile) {
    enableMobileMode()
  }
}, [isMobile])
```

---

## 7. Put Interaction Logic in Event Handlers

**Impact: MEDIUM** - Avoids effect re-runs and duplicate side effects

If a side effect is triggered by a user action, run it in the event handler, not in an effect.

**Incorrect: event modeled as state + effect**

```tsx
function Form() {
  const [submitted, setSubmitted] = useState(false)
  const theme = useContext(ThemeContext)

  useEffect(() => {
    if (submitted) {
      post('/api/register')
      showToast('Registered', theme)
    }
  }, [submitted, theme])

  return <button onClick={() => setSubmitted(true)}>Submit</button>
}
```

**Correct: do it in the handler**

```tsx
function Form() {
  const theme = useContext(ThemeContext)

  function handleSubmit() {
    post('/api/register')
    showToast('Registered', theme)
  }

  return <button onClick={handleSubmit}>Submit</button>
}
```

Reference: [Should this code move to an event handler?](https://react.dev/learn/removing-effect-dependencies#should-this-code-move-to-an-event-handler)

---

## 8. Subscribe to Derived State

**Impact: MEDIUM** - Reduces re-render frequency

Subscribe to derived boolean state instead of continuous values.

**Incorrect: re-renders on every pixel change**

```tsx
function Sidebar() {
  const width = useWindowWidth() // updates continuously
  const isMobile = width < 768
  return <nav className={isMobile ? 'mobile' : 'desktop'} />
}
```

**Correct: re-renders only when boolean changes**

```tsx
function Sidebar() {
  const isMobile = useMediaQuery('(max-width: 767px)')
  return <nav className={isMobile ? 'mobile' : 'desktop'} />
}
```

---

## 9. Use Functional setState Updates

**Impact: MEDIUM** - Prevents stale closures and unnecessary callback recreations

Use functional updates when updating state based on current value.

**Incorrect: requires state as dependency**

```tsx
function TodoList() {
  const [items, setItems] = useState(initialItems)

  // Callback recreated on every items change
  const addItems = useCallback((newItems: Item[]) => {
    setItems([...items, ...newItems])
  }, [items]) // items dependency causes recreations

  // Stale closure bug
  const removeItem = useCallback((id: string) => {
    setItems(items.filter(item => item.id !== id))
  }, []) // Missing items dependency!

  return <List items={items} onAdd={addItems} onRemove={removeItem} />
}
```

**Correct: stable callbacks, no stale closures**

```tsx
function TodoList() {
  const [items, setItems] = useState(initialItems)

  const addItems = useCallback((newItems: Item[]) => {
    setItems(curr => [...curr, ...newItems])
  }, []) // No dependencies needed

  const removeItem = useCallback((id: string) => {
    setItems(curr => curr.filter(item => item.id !== id))
  }, []) // Safe and stable

  return <List items={items} onAdd={addItems} onRemove={removeItem} />
}
```

**When to use functional updates:**
- Any setState that depends on the current state value
- Inside useCallback/useMemo when state is needed
- Event handlers that reference state
- Async operations that update state

**When direct updates are fine:**
- Setting state to a static value: `setCount(0)`
- Setting state from props/arguments only: `setName(newName)`

---

## 10. Use Lazy State Initialization

**Impact: MEDIUM** - Wasted computation on every render

Pass a function to `useState` for expensive initial values.

**Incorrect: runs on every render**

```tsx
function FilteredList({ items }: { items: Item[] }) {
  // buildSearchIndex() runs on EVERY render
  const [searchIndex, setSearchIndex] = useState(buildSearchIndex(items))
  const [query, setQuery] = useState('')

  return <Search index={searchIndex} query={query} />
}

function UserProfile() {
  // JSON.parse runs on every render
  const [settings, setSettings] = useState(
    JSON.parse(localStorage.getItem('settings') || '{}')
  )

  return <Settings data={settings} />
}
```

**Correct: runs only once**

```tsx
function FilteredList({ items }: { items: Item[] }) {
  const [searchIndex, setSearchIndex] = useState(() => buildSearchIndex(items))
  const [query, setQuery] = useState('')

  return <Search index={searchIndex} query={query} />
}

function UserProfile() {
  const [settings, setSettings] = useState(() => {
    const stored = localStorage.getItem('settings')
    return stored ? JSON.parse(stored) : {}
  })

  return <Settings data={settings} />
}
```

**Use lazy initialization for:**
- localStorage/sessionStorage reads
- Building data structures (indexes, maps)
- Heavy transformations

**Skip for:** Simple primitives, direct references, cheap literals.

---

## 11. Use Transitions for Non-Urgent Updates

**Impact: MEDIUM** - Maintains UI responsiveness

Mark frequent, non-urgent state updates as transitions.

**Incorrect: blocks UI on every scroll**

```tsx
function ScrollTracker() {
  const [scrollY, setScrollY] = useState(0)
  useEffect(() => {
    const handler = () => setScrollY(window.scrollY)
    window.addEventListener('scroll', handler, { passive: true })
    return () => window.removeEventListener('scroll', handler)
  }, [])
}
```

**Correct: non-blocking updates**

```tsx
import { startTransition } from 'react'

function ScrollTracker() {
  const [scrollY, setScrollY] = useState(0)
  useEffect(() => {
    const handler = () => {
      startTransition(() => setScrollY(window.scrollY))
    }
    window.addEventListener('scroll', handler, { passive: true })
    return () => window.removeEventListener('scroll', handler)
  }, [])
}
```

---

## 12. Use useRef for Transient Values

**Impact: MEDIUM** - Avoids unnecessary re-renders on frequent updates

When a value changes frequently and doesn't need to trigger re-renders, use `useRef`.

**Incorrect: renders every update**

```tsx
function Tracker() {
  const [lastX, setLastX] = useState(0)

  useEffect(() => {
    const onMove = (e: MouseEvent) => setLastX(e.clientX)
    window.addEventListener('mousemove', onMove)
    return () => window.removeEventListener('mousemove', onMove)
  }, [])

  return <Dot x={lastX} />
}
```

**Correct: no re-render for tracking**

```tsx
function Tracker() {
  const lastXRef = useRef(0)
  const dotRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const onMove = (e: MouseEvent) => {
      lastXRef.current = e.clientX
      const node = dotRef.current
      if (node) {
        node.style.transform = `translateX(${e.clientX}px)`
      }
    }
    window.addEventListener('mousemove', onMove)
    return () => window.removeEventListener('mousemove', onMove)
  }, [])

  return <div ref={dotRef} className="dot" />
}
```

---

## Quick Reference

| Pattern | Impact | Symptom |
|---------|--------|---------|
| Derived state | MEDIUM | State + effect for computed values |
| Defer reads | MEDIUM | Subscribing to state only used in callbacks |
| Skip simple useMemo | LOW-MEDIUM | Memoizing primitives/booleans |
| Constant defaults | MEDIUM | Memoized component re-renders without props |
| Memoized components | MEDIUM | Expensive computation before early return |
| Narrow dependencies | LOW | Effect runs too often |
| Event handlers | MEDIUM | Side effects in useEffect for user actions |
| Derived subscriptions | MEDIUM | Re-renders on continuous value changes |
| Functional setState | MEDIUM | Stale closures, recreating callbacks |
| Lazy initialization | MEDIUM | Expensive initial state on every render |
| Transitions | MEDIUM | UI blocks on non-urgent updates |
| useRef for transient | MEDIUM | Re-renders on frequent value changes |
